run68簡易デバッガの使い方 run68 version0.7
Dec.1999 by Chack'n

1.はじめに

 run68簡易デバッガは、run68自身のデバッグを目的として作られた機能です。
 具体的には、run68で動作しないプログラムがなぜ動作しないのかを突き止め、
 run68に実装されていない、あるいは誤って実装された命令やファンクション
 コールをデバッグするのに使います。run68で動かしたいけれども動かない
 ソフトをお手元にお持ちの方は、是非お試しください。その上で解析結果を
 私どもにお送りいただけると、できるだけ速やかに修正いたします。
 ご自分で修正していただいてももちろん結構ですが、その場合もできるだけ、
 私どもに修正箇所と内容をフィードバックいただきたいと思います。
 run68.txtの「9. 協力のお願い」を参照してください。

2.起動

 run68を-debugオプションを付けて起動すると、run68簡易デバッガが起動します。

  C>run68 -debug <プログラム名>
  デバッガを起動します。
  D0-D7=00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
  A0-A7=00033C00,0003F644,00023C00,00021C00,00033D00,00000000,00000000,00033C00
    PC=00033D00    SR=0000
  $033D00 4BFA 3C82                 lea.l   15490(pc),a5
  (run68)

 また、アプリケーションプログラムがアドレスエラーやバスエラーになった
 時にも自動的に起動します。

3.ヘルプコマンド

 run68簡易デバッガのコマンド一覧を表示します。この一覧は、helpコマンド
 で表示されます。

       ============= run68 debugger commands =============
break $adr      - Set a breakpoint.
clear           - Clear the breakpoint.
cont            - Continue running.
cont n          - Continue running and stops after executing n instructions.
dump $adr [n]   - Dump memory (n bytes) from $adr.
dump [n]        - Dump memory (n bytes) continuously.
help            - Show this menu.
history [n]     - Show last n instructions executed.
list $adr [n]   - Disassemble from $adr.
list [n]        - Disassemble n instructions from current PC.
quit            - Quit from run68.
reg             - Display registers.
run             - Run Human68k program from the begining.
step            - Execute only one instruction.
step n          - Continue running with showing all registers
                  and stops after executing n instructions.

4.breakコマンドとclearコマンド

 run68簡易デバッガは、同時に一つだけブレークポイントを設定できます。
 シンボル情報は使えないので、$で始まるアドレスを指定します。

(run68)break $33d40
(run68)cont
(run68) breakpoint:MPUがアドレス$033D40の命令を実行しました。
D0-D7=00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
A0-A7=00033C10,0000BA34,00023C00,00021C00,00000000,00037984,00000000,0003F57C
  PC=00033D40    SR=2004
$033D40 FF20                      FCALL $20
(run68)

 設定したブレークポイントはclearコマンドで無効化されます。

(run68)clear
(run68)break
run68-break:No breakpoints set.

 単にbreakと打つと、設定中のブレークポイントアドレスが表示されます。

(run68)break
run68-break:Breakpoint is set to $033D40.

5.cont/step/run/quitコマンド

 runコマンドは、プログラムをメモリにロードしてその先頭にPCを
 移動します、現時点では続いてcontしないとプログラムの実行は
 開始しません。また、runコマンドでアプリケーションのコマンド
 ラインを変更する機能もありません。run68をquitしないで何度も
 デバッグ実行を繰返す時に使います。

(run68)run
デバッガを起動します。
D0-D7=00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
A0-A7=00033C00,0003F644,00023C00,00021C00,00033D00,00037984,00000000,00033C00
  PC=00033D00    SR=0004
$033D00 4BFA 3C82                 lea.l   15490(pc),a5
(run68)

 contはCPUを連続実行するコマンドです。引数に整数値を指定すると、
 n命令実行したところでCPUをストップさせることができます。
 stepはCPU命令を1命令だけ実行してストップします。引数に整数値
 を付けると、step実行をn命令分だけ繰返します。contコマンドと
 stepコマンドをうまく組合わせて、プログラムの動作がおかしくなる
 箇所を追いつめていきます。

(run68)step
D0-D7=00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
A0-A7=00033C10,0000BA34,00023C00,00021C00,00000000,00037984,00000000,0003F57C
  PC=00033D44    SR=0004
$033D44 2F0B                      move.l  a3,-(a7)
(run68)

 run68を終了する時にはquitコマンドを使います。

6.dumpコマンド

 dumpコマンドはX68000の仮想メモリ空間をダンプします。
 アドレスとバイト数を指定してください。バイト数は省略可能です。
 最初にダンプ開始アドレスを指定すると、2回目でアドレス指定を
 省略でき、そうすると前回ダンプしたメモリの次のアドレスから
 ダンプを開始します。

(run68)dump $3f57c 128
03F57C:00 03 F5 7C 00 00 00 00-00 00 00 00 00 00 00 00:...|............
03F58C:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F59C:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F5AC:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F5BC:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F5CC:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F5DC:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................
03F5EC:00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00:................

7.listコマンドとhistoryコマンド

 listコマンドとhistoryコマンドは、それぞれ逆アセンブルと命令実行
 履歴を表示します。命令のデコードは、命令の実行とは全く別のコード
 を書き起こしています。どちらかにバグがあると、ディスアセンブル
 した内容と実行した内容に違いが生じてしまいます。
 listコマンドはアドレスを指定しないと、現在のプログラムカウンタ
 の位置からディスアセンブルを開始します。また、ディスアセンブル
 する命令数を指定することもできます。アドレスを省略してlistコマンド
 を連続して実行すると、連続したアドレスがディスアセンブルされます。

(run68)list
$033D00 4BFA 3C82                 lea.l   15490(pc),a5
$033D04 4FED 7C00                 lea.l   31744(a5),a7
$033D08 2F28 0060                 move.l  96(a0),-(a7)
$033D0C 2848                      movea.l a0,a4
$033D0E 41E8 0010                 lea.l   16(a0),a0
$033D12 93C8                      suba.l  a0,a1
$033D14 2F09                      move.l  a1,-(a7)
$033D16 2F08                      move.l  a0,-(a7)
$033D18 FF4A                      FCALL $4A
$033D1A 508F                      addq.l  #8,a7

 historyコマンドは、最近実行された命令を表示します。run68は実行
 した命令のアドレスだけを記憶しています。最大2000命令まで表示でき
 ます。命令コードが誤って上書きされたりすると、ディスアセンブル結果
 は実際に実行したコードとは違うものが表示されるので気を付けてください。

(run68)history
** EXECUTED INSTRUCTION HISTORY **
ADDRESS OPCODE                    MNEMONIC
-------------------------------------------------------
$033D20 2E80                      move.l  d0,(a7)
$033D22 2854                      movea.l (a4),a4
$033D24 200C                      move.l  a4,d0
$033D26 6718                      beq.b   $033D40
$033D28 0CAC 6461 7368 0010       cmp.l   #$64617368,16(a4)
$033D30 66F0                      bne.b   $033D22
$033D22 2854                      movea.l (a4),a4
$033D24 200C                      move.l  a4,d0
$033D26 6718                      beq.b   $033D40
$033D40 FF20                      FCALL $20

8.regコマンド

 regコマンドはMC68000の全てのレジスタの内容を表示します。現在の
 所、レジスタの内容を書きかえる機能は有していません。

(run68)reg
D0-D7=00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
A0-A7=00033C10,0000BA34,00023C00,00021C00,00000000,00037984,00000000,0003F57C
  PC=00033D42    SR=0004

(EOF)
